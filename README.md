task_1:
Поменял оператор с функцией .append на list_comprehension, который работает немного быстрей (примерно в 2 раза). 
Результат с использованием функции .append 0,0223464351 
Результат с list_comprehension 0,011275100056

task_2:
Мемоизация в виде декоратора @memoize ускоряет выполнение функции на более чем на 1 порядок.
При изменении количества цифр в num_100, num_1000, num_10000, картина не поменялась.
При использовании мемоизации мы сохраняем промежуточные результаты в словаре cache для того, что бы в следующих рассчетах не повторять тоже самое.
В рекурсивной функции мы повторяем вызов функции пока не закончатся все цифры -это занимает много памяти.
Благодаря мемоизации получилось снизить сложность с O(2^n) на О(n)

task_3:
Места по скорости выполнения кода:
1е встроенная функция reversed() и срез строки [::-1] - нет перебора по элементам.
2е рекурсия и цикл while, отстают более чем на 1 порядок от 1го места - присутствует перебор по эл-ам, время выполнения кода увеличивается.
3е место оператор ветвления if else, самое медленное выполнение кода - присутствует перебор по эл-ам.
Время выполнения кода увеличивается, плюс при каждом проходе сравнивание с 0 в новом цикле.

task_4:
До решения в 1 строчку не додумался, но при повторных замеров вариант со словарем и встроенной функцией sorted() оказался самым быстрым.
Добавил проверку профилировщиклом cProfile. 
