task_1:
Поменял список с методом .append на list_comprehension, который работает немного быстрей (примерно в 2 раза). 
Результат с использованием функции .append 0,0223464351 
Результат с list_comprehension 0,011275100056

task_2:
Мемоизация в виде декоратора @memoize выполняет функцию словаря для записи нового числа.
Можно было воспользоваться словарем без объявления мемоизации, рез-т будет тем же.

task_3:
Места по скорости выполнения кода:
1е встроенная функция reversed() и срез строки [::-1] - нет перебора по элементам.
2е рекурсия и цикл while, отстают более чем на 1 порядок от 1го места - присутствует перебор по эл-ам, время выполнения кода увеличивается.
3е место оператор ветвления if else, самое медленное выполнение кода - присутствует перебор по эл-ам.
Время выполнения кода увеличивается, плюс при каждом проходе сравнивание с 0 в новом цикле.

task_4:
До решения в 1 строчку не додумался, но при повторных замеров вариант со словарем и встроенной функцией sorted() оказался самым быстрым.
Добавил проверку профилировщиклом cProfile. 
 
